{
  "hash": "41dfe0eb0c7b0759b3018bf17174d328",
  "result": {
    "engine": "knitr",
    "markdown": "# Smoothing Techniques in Statistics\n\n\\newcommand{\\E}{\\mathbb E}\n\\newcommand{\\R}{\\mathbb{R}}\n\\newcommand{\\var}{\\mathbb{V}ar}\n\\newcommand{\\bx}{\\mathbf{x}}\n\\newcommand{\\bX}{\\mathbf{X}}\n\\newcommand{\\cov}{\\mathbb{C}ov}\n\\newcommand{\\mse}{\\mathrm{MSE}}\n\\newcommand{\\corr}{\\mathbb{C}orr}\n\\newcommand{\\unif}{\\operatorname{Unif}}\n\\newcommand{\\geom}{\\operatorname{Geom}}\n\\newcommand{\\bet}{\\operatorname{Beta}}\n\\newcommand{\\bern}{\\operatorname{Bern}}\n\\newcommand{\\iid}{\\overset{iid}{\\sim}}\n\\newcommand{\\ef}{\\operatorname{Eff}}\n\\newcommand{\\htt}{\\hat \\theta}\n\\newcommand{\\b}{\\mathbb b}\n\n\n\nIn statistics, we often deal with data. However, we know that there exist random noise when collecting the data. But what if the data contains too much noise, will we get any useful information?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\n\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n\n# Moving average smoother\nsmoothed_y <- stats::filter(y, rep(1/5, 5), sides = 2)\n\n# Data frame\ndf <- data.frame(x = x, y = y, \n                 smoothed_y = as.numeric(smoothed_y))\n\n# Plot\nggplot(df, aes(x = x)) +\n  geom_line(aes(y = y, color = \"Noisy Data\"), linewidth = 0.6) +\n  geom_point(aes(y = y, color = \"Noisy Data\"), shape = 21, fill = \"gray60\", color = \"gray40\", size = 2) +\n  geom_line(aes(y = smoothed_y, color = \"Smoothed Data\"), linewidth = 1.2) +\n  scale_color_manual(values = c(\"Noisy Data\" = \"gray50\",\n                                \"Smoothed Data\" = \"red\"),\n    name = NULL) +\n  labs(title = \"Noisy Data with Smoothed Fit\",\n        x = \"X\",y = \"Y\") +\n  theme_minimal(base_size = 14) +\n  theme(\n    legend.position = \"top\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 4 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/noise-smoothing-1.png){width=672}\n:::\n:::\n\n\nOnce the data is smoothed, we can see the underlying trend more clearly. Smoothing techniques are widely used in various fields such as signal processing, time series analysis, and machine learning to enhance data quality and extract meaningful patterns. In this chapter, we will see a few techniques for smoothing data.\n\n### Moving Average Smoothing\n\nOne of the simplest smoothing techniques is the **moving average.** The moving average smooths data by averaging neighboring data points. The formula for a simple moving average with a window size of $k$ is given by:\n$$\nx_i^{\\text{smoothed}} = \\frac{1}{k} \\sum_{j=i-\\frac{k-1}{2}}^{i+\\frac{k-1}{2}} x_j,\n$$\nwhere $x_i$ is the original data point, and $x_i^{\\text{smoothed}}$ is the smoothed data point.\n\n::: {.callout-example title=\"Example: Moving Average Smoothing\"}\nSuppose $\\bx=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply a moving average smoother with a window size of $k$ to smooth the data, where $k=1,3,\\dots,11$. The following R code demonstrates how to implement moving average smoothing with different window sizes and visualize the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n\n# Moving average smoother (use odd windows to align with your legend)\nk <- c(3, 5, 7, 9, 11)\n\nsmoothed_y_list <- lapply(k, function(window_size) {\n  # centered moving average; edges will be NA (thatâ€™s expected)\n  stats::filter(y, rep(1 / window_size, window_size), sides = 2)\n})\n\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(k)) {\n  df[[paste0(\"smoothed_y_\", k[i])]] <- as.numeric(smoothed_y_list[[i]])\n}\n\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\n\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n\n# Order legend nicely and provide clean labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_\", k))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_3\"  = \"Window Size 3\",\n  \"smoothed_y_5\"  = \"Window Size 5\",\n  \"smoothed_y_7\"  = \"Window Size 7\",\n  \"smoothed_y_9\"  = \"Window Size 9\",\n  \"smoothed_y_11\" = \"Window Size 11\"\n)\n\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_3\"  = \"blue\",\n  \"smoothed_y_5\"  = \"red\",\n  \"smoothed_y_7\"  = \"green\",\n  \"smoothed_y_9\"  = \"purple\",\n  \"smoothed_y_11\" = \"orange\"\n)\n\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\n\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line(na.rm = TRUE) +\n  labs(\n    title = \"Moving Average Smoothing with Different Window Sizes\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/moving-average-smoothing-1.png){width=672}\n:::\n:::\n\n:::\n\n### Kernel Smoothing\n\nAnother popular smoothing technique is **kernel smoothing.** Kernel smoothing uses a kernel function to weight neighboring data points when estimating the smoothed value at a given point. The formula for kernel smoothing is given by:\n$$\nx_i^{\\text{smoothed}} = \\frac{\\sum_{j=1}^{n} K\\left(\\frac{x_i - x_j}{h}\\right) x_j}{\\sum_{j=1}^{n} K\\left(\\frac{x_i - x_j}{h}\\right)},\n$$\nwhere $K$ is the kernel function, $h$ is the bandwidth parameter, and $x_i^{\\text{smoothed}}$ is the smoothed data point.\n\nSome common kernel functions include the following:\n\n* Gaussian kernel: $K(u) = \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{1}{2}u^2}$ \n* Epanechnikov kernel: $K(u) = \\frac{3}{4}(1-u^2)$ for $|u| \\leq 1$, and $0$ otherwise\n* uniform kernel: $K(u) = \\frac{1}{2}$ for $|u| \\leq 1$, and $0$ otherwise\n\n::: {.callout-note title=\"Choice of the kernel and the bandwidth\"}\nThe choice of the kernel function $K$ is often less critical than the choice of the bandwidth $h$. Common choices like the Gaussian kernel are widely used due to their smoothness and mathematical properties.\n\nThe choice of bandwidth $h$ is crucial, as it determines the degree of smoothing. A smaller bandwidth results in less smoothing, while a larger bandwidth leads to more smoothing.\n:::\n\n::: {.callout-example title=\"Example: Kernel Smoothing\"}\nSuppose $\\bx=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply kernel smoothing with different bandwidths $h$ to smooth the data, where $h=0.1,0.3,0.5,0.7,1.0$. The following R code demonstrates how to implement kernel smoothing with different bandwidths and visualize the results.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n# Kernel smoother function\nkernel_smooth <- function(x, y, h) {\n  n <- length(x)\n  smoothed_y <- numeric(n)\n  for (i in 1:n) {\n    weights <- dnorm((x[i] - x) / h)\n    smoothed_y[i] <- sum(weights * y) / sum(weights)\n  }\n  return(smoothed_y)\n}\n# Bandwidths\nh_values <- c(0.1, 0.3, 0.5, 0.7, 1.0)\nsmoothed_y_list <- lapply(h_values, function(h) {\n  kernel_smooth(x, y, h)\n})\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(h_values)) {\n  df[[paste0(\"smoothed_y_h\", h_values[i])]] <- smoothed_y_list[[i]]\n}\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n# Order legend nicely and provide clean labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_h\", h_values))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_h0.1\" = \"Bandwidth 0.1\",\n  \"smoothed_y_h0.3\" = \"Bandwidth 0.3\",\n  \"smoothed_y_h0.5\" = \"Bandwidth 0.5\",\n  \"smoothed_y_h0.7\" = \"Bandwidth 0.7\",\n  \"smoothed_y_h1\"   = \"Bandwidth 1.0\"\n)\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_h0.1\" = \"blue\",\n  \"smoothed_y_h0.3\" = \"red\",\n  \"smoothed_y_h0.5\" = \"green\",\n  \"smoothed_y_h0.7\" = \"purple\",\n  \"smoothed_y_h1\"   = \"orange\"\n)\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line() +\n  labs(\n    title = \"Kernel Smoothing with Different Bandwidths\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/kernel-smoothing-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n### Smoothing Splines\n\nSmoothing splines are a flexible method for smoothing data by fitting a piecewise polynomial function to the data points. The smoothing spline minimizes the following objective function: \n$$\n\\sum_{i=1}^{n} \\{y_i - f(x_i)\\}^2 + \\lambda \\int (f''(x))^2 dx,\n$$\nwhere $y_i$ are the observed data points, $f(x)$ is the smoothing spline, $\\lambda$ is the smoothing parameter that controls the trade-off between fidelity to the data and smoothness of the spline, and $f''(x)$ is the second derivative of the spline function.\n\n::: {.callout-example title=\"Example: Smoothing Splines\"}\nSuppose $\\bx=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply smoothing splines with different smoothing parameters $\\lambda$ to smooth the data, where $\\lambda=0.01,0.1,1,10,100$. The following R code demonstrates how to implement smoothing splines with different smoothing parameters and visualize the results.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n\n# Smoothing spline using lambda (penalty on curvature)\nsmoothing_spline <- function(x, y, lambda) {\n  fit <- smooth.spline(x, y, lambda = lambda)  # <-- use lambda, not spar\n  predict(fit, x)$y\n}\n\n# Smoothing parameters (penalty sizes)\nlambda_values <- c(0.01, 0.1, 1, 10, 100)\n\nsmoothed_y_list <- lapply(lambda_values, function(lambda) {\n  smoothing_spline(x, y, lambda)\n})\n\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(lambda_values)) {\n  nm <- paste0(\"smoothed_y_lambda\", lambda_values[i])\n  df[[nm]] <- smoothed_y_list[[i]]\n}\n\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\n\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n\n# Order legend & labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_lambda\", lambda_values))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_lambda0.01\" = \"Lambda 0.01\",\n  \"smoothed_y_lambda0.1\"  = \"Lambda 0.1\",\n  \"smoothed_y_lambda1\"    = \"Lambda 1\",\n  \"smoothed_y_lambda10\"   = \"Lambda 10\",\n  \"smoothed_y_lambda100\"  = \"Lambda 100\"\n)\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_lambda0.01\" = \"blue\",\n  \"smoothed_y_lambda0.1\"  = \"red\",\n  \"smoothed_y_lambda1\"    = \"green\",\n  \"smoothed_y_lambda10\"   = \"purple\",\n  \"smoothed_y_lambda100\"  = \"orange\"\n)\n\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\n\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line() +\n  labs(\n    title = \"Smoothing Splines with Different Penalties (lambda)\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/smoothing-splines-1.png){width=672}\n:::\n:::\n\n:::\n\n--- \n\n## Reference:\n\n+ Gu, C. (2013). [Smoothing Spline ANOVA Models](https://link.springer.com/book/10.1007/978-1-4757-3683-0). Springer, 2nd Edition.\n\n+ Ramsay, J.O., Hooker, G. and Graves, S. (2009). [Functional Data Analysis with R and MATLAB](https://link.springer.com/book/10.1007/978-0-387-98185-7). Springer.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}