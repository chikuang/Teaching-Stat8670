{
  "hash": "5d9da7c2fe9d1d5cb7c31e8b4371720a",
  "result": {
    "engine": "knitr",
    "markdown": "# Smoothing Techniques in Statistics\n\n\\newcommand{\\E}{\\mathbb E}\n\\newcommand{\\R}{\\mathbb{R}}\n\\newcommand{\\var}{\\mathbb{V}ar}\n\\newcommand{\\bx}{\\mathbf{x}}\n\\newcommand{\\bX}{\\mathbf{X}}\n\\newcommand{\\cov}{\\mathbb{C}ov}\n\\newcommand{\\mse}{\\mathrm{MSE}}\n\\newcommand{\\corr}{\\mathbb{C}orr}\n\\newcommand{\\unif}{\\operatorname{Unif}}\n\\newcommand{\\geom}{\\operatorname{Geom}}\n\\newcommand{\\bet}{\\operatorname{Beta}}\n\\newcommand{\\bern}{\\operatorname{Bern}}\n\\newcommand{\\iid}{\\overset{iid}{\\sim}}\n\\newcommand{\\ef}{\\operatorname{Eff}}\n\\newcommand{\\htt}{\\hat \\theta}\n\\newcommand{\\b}{\\mathbb b}\n\n\n\nIn statistics, we often deal with data. However, we know that there exist random noise when collecting the data. But what if the data contains too much noise, will we get any useful information?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\n\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n\n# Moving average smoother\nsmoothed_y <- stats::filter(y, rep(1/5, 5), sides = 2)\n\n# Data frame\ndf <- data.frame(x = x, y = y, \n                 smoothed_y = as.numeric(smoothed_y))\n\n# Plot\nggplot(df, aes(x = x)) +\n  geom_line(aes(y = y, color = \"Noisy Data\"), linewidth = 0.6) +\n  geom_point(aes(y = y, color = \"Noisy Data\"), shape = 21, fill = \"gray60\", color = \"gray40\", size = 2) +\n  geom_line(aes(y = smoothed_y, color = \"Smoothed Data\"), linewidth = 1.2) +\n  scale_color_manual(values = c(\"Noisy Data\" = \"gray50\",\n                                \"Smoothed Data\" = \"red\"),\n    name = NULL) +\n  labs(title = \"Noisy Data with Smoothed Fit\",\n        x = \"X\",y = \"Y\") +\n  theme_minimal(base_size = 14) +\n  theme(\n    legend.position = \"top\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 4 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/noise-smoothing-1.png){width=672}\n:::\n:::\n\n\nOnce the data is smoothed, we can see the underlying trend more clearly. Smoothing techniques are widely used in various fields such as signal processing, time series analysis, and machine learning to enhance data quality and extract meaningful patterns. In this chapter, we will see a few techniques for smoothing data.\n\n## Moving Average Smoothing\n\nOne of the simplest smoothing techniques is the **moving average.** The moving average smooths data by averaging neighboring data points. The formula for a simple moving average with a window size of $k$ is given by: $$\nx_i^{\\text{smoothed}} = \\frac{1}{k} \\sum_{j=i-\\frac{k-1}{2}}^{i+\\frac{k-1}{2}} x_j,\n$$ where $x_i$ is the original data point, and $x_i^{\\text{smoothed}}$ is the smoothed data point.\n\n::: {.callout-example title=\"Example: Moving Average Smoothing\"}\nSuppose $\\mathbf{x}=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply a moving average smoother with a window size of $k$ to smooth the data, where $k=1,3,\\dots,11$. The following R code demonstrates how to implement moving average smoothing with different window sizes and visualize the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n\n# Moving average smoother (use odd windows to align with your legend)\nk <- c(3, 5, 7, 9, 11)\n\nsmoothed_y_list <- lapply(k, function(window_size) {\n  # centered moving average; edges will be NA (that’s expected)\n  stats::filter(y, rep(1 / window_size, window_size), sides = 2)\n})\n\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(k)) {\n  df[[paste0(\"smoothed_y_\", k[i])]] <- as.numeric(smoothed_y_list[[i]])\n}\n\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\n\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n\n# Order legend nicely and provide clean labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_\", k))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_3\"  = \"Window Size 3\",\n  \"smoothed_y_5\"  = \"Window Size 5\",\n  \"smoothed_y_7\"  = \"Window Size 7\",\n  \"smoothed_y_9\"  = \"Window Size 9\",\n  \"smoothed_y_11\" = \"Window Size 11\"\n)\n\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_3\"  = \"blue\",\n  \"smoothed_y_5\"  = \"red\",\n  \"smoothed_y_7\"  = \"green\",\n  \"smoothed_y_9\"  = \"purple\",\n  \"smoothed_y_11\" = \"orange\"\n)\n\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\n\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line(na.rm = TRUE) +\n  labs(\n    title = \"Moving Average Smoothing with Different Window Sizes\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/moving-average-smoothing-1.png){width=672}\n:::\n:::\n\n:::\n\n## Local Regression\n\nLOESS (Locally Estimated Scatterplot Smoothing) is a non-parametric regression method that combines multiple regression models in a k-nearest-neighbor-based meta-model. It is particularly useful for smoothing scatterplots. The LOESS method fits simple models to localized subsets of the data to build up a function that describes the deterministic part of the variation in the data, point by point. \n\n$$\nY_i=\\mu\\left(x_i\\right)+\\varepsilon_i,\n$$\nwhere $\\mu(x)$ is the unknown *smooth* regression function to be estimated, and represents the conditional expectation of the response, given a value of the predictor variables, and the $\\varepsilon$ is the random error. Local regression then estimates the function $\\mu( x )$, for one value of $x$ at a time. Since the function is assumed to be smooth, the most informative data points are those whose $x_i$ values are close to $x$. This is formalized with a bandwidth $h$  and a kernel or weight function $W( \\cdot)$, with observations assigned weights \n$$w_i ( x ) = W \\left( \\frac{x_i − x}{h}\\right). $$\n\nA typical choice of $W$, used by Cleveland in LOWESS, is $W(u)=(1-|u|^{3})^{3}$ for $|u|<1$, although any similar function (peaked at $u=0$ and small or 0 for large values of $u$) can be used. Questions of bandwidth selection and specification (how large should $h$ be, and should it vary depending upon the fitting point $x$?) are deferred for now.\n\nA local model (usually a low-order polynomial with degree $p\\leq 3$, expressed as $\\mu (x_{i})\\approx \\beta _{0}+\\beta _{1}(x_{i}-x)+\\ldots +\\beta _{p}(x_{i}-x)^{p}$ is then fitted by weighted least squares: choose regression coefficients $\\left(\\hat{\\beta }_{0},\\ldots ,{\\hat {\\beta }}_{p})\\right)$ to minimize \n$$\n\\sum_{i=1}^n w_i(x)\\left(Y_i-\\beta_0-\\beta_1\\left(x_i-x\\right)-\\ldots-\\beta_p\\left(x_i-x\\right)^p\\right)^2 .\n$$\n\nPutting everything into a matrix form, we have\n$$\n\\hat{\\boldsymbol{\\beta}}=\\left(\\mathbf{X}^{\\boldsymbol{\\top}} \\mathbf{W} \\mathbf{X}\\right)^{-1} \\mathbf{X}^{\\boldsymbol{\\top}} \\mathbf{W} \\mathbf{y},\n$$\nwhere $\\hat {\\boldsymbol {\\beta }}$ is a vector of the local regression coefficients; $X$ is the  $n\\times (p+1)$ design matrix with entries $(x_{i}-x)^{j}$; $W$ is a diagonal matrix of the smoothing weights $w_{i}(x)$; and $y$  is a vector of the responses $Y_i$. \n\n::: {.callout-example title=\"Example: LOESS Smoothing\"}\nSuppose $\\mathbf{x}=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply LOESS smoothing with different span parameters to smooth the data, where $span=0.1,0.3,0.5,0.7,1.0$. The following R code demonstrates how to implement LOESS smoothing with different span parameters and visualize the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n# LOESS smoother function\nloess_smooth <- function(x, y, span) {\n  fit <- loess(y ~ x, span = span)\n  predict(fit, x)\n}\n# Span values\nspan_values <- c(0.1, 0.3, 0.5, 0.7, 1.0)\nsmoothed_y_list <- lapply(span_values, function(span) {\n  loess_smooth(x, y, span)\n})\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(span_values)) {\n  df[[paste0(\"smoothed_y_span\", span_values[i])]] <- smoothed_y_list[[i]]\n}\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n# Order legend nicely and provide clean labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_span\", span_values))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_span0.1\" = \"Span 0.1\",\n  \"smoothed_y_span0.3\" = \"Span 0.3\",\n  \"smoothed_y_span0.5\" = \"Span 0.5\",\n  \"smoothed_y_span0.7\" = \"Span 0.7\",\n  \"smoothed_y_span1\"   = \"Span 1.0\"\n)\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_span0.1\" = \"blue\",\n  \"smoothed_y_span0.3\" = \"red\",\n  \"smoothed_y_span0.5\" = \"green\",\n  \"smoothed_y_span0.7\" = \"purple\",\n  \"smoothed_y_span1\"   = \"orange\"\n)\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line() +\n  labs(\n    title = \"LOESS Smoothing with Different Span Parameters\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/loess-smoothing-1.png){width=672}\n:::\n:::\n\n:::\n\n## Kernel Smoothing\n\nAnother popular smoothing technique is **kernel smoothing.** Kernel smoothing uses a kernel function to weight neighboring data points when estimating the smoothed value at a given point. The formula for kernel smoothing is given by: $$\nx_i^{\\text{smoothed}} = \\frac{\\sum_{j=1}^{n} K\\left(\\frac{x_i - x_j}{h}\\right) x_j}{\\sum_{j=1}^{n} K\\left(\\frac{x_i - x_j}{h}\\right)},\n$$ where $K$ is the kernel function, $h$ is the bandwidth parameter, and $x_i^{\\text{smoothed}}$ is the smoothed data point.\n\nSome common kernel functions include the following:\n\n-   Gaussian kernel: $K(u) = \\frac{1}{\\sqrt{2\\pi}} e^{-\\frac{1}{2}u^2}$\n-   Epanechnikov kernel: $K(u) = \\frac{3}{4}(1-u^2)$ for $|u| \\leq 1$, and $0$ otherwise\n-   uniform kernel: $K(u) = \\frac{1}{2}$ for $|u| \\leq 1$, and $0$ otherwise\n\n::: {.callout-note title=\"Choice of the kernel and the bandwidth\"}\nThe choice of the kernel function $K$ is often less critical than the choice of the bandwidth $h$. Common choices like the Gaussian kernel are widely used due to their smoothness and mathematical properties.\n\nThe choice of bandwidth $h$ is crucial, as it determines the degree of smoothing. A smaller bandwidth results in less smoothing, while a larger bandwidth leads to more smoothing.\n:::\n\n::: {.callout-example title=\"Example: Kernel Smoothing\"}\nSuppose $\\mathbf{x}=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply kernel smoothing with different bandwidths $h$ to smooth the data, where $h=0.1,0.3,0.5,0.7,1.0$. The following R code demonstrates how to implement kernel smoothing with different bandwidths and visualize the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n# Kernel smoother function\nkernel_smooth <- function(x, y, h) {\n  n <- length(x)\n  smoothed_y <- numeric(n)\n  for (i in 1:n) {\n    weights <- dnorm((x[i] - x) / h)\n    smoothed_y[i] <- sum(weights * y) / sum(weights)\n  }\n  return(smoothed_y)\n}\n# Bandwidths\nh_values <- c(0.1, 0.3, 0.5, 0.7, 1.0)\nsmoothed_y_list <- lapply(h_values, function(h) {\n  kernel_smooth(x, y, h)\n})\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(h_values)) {\n  df[[paste0(\"smoothed_y_h\", h_values[i])]] <- smoothed_y_list[[i]]\n}\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n# Order legend nicely and provide clean labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_h\", h_values))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_h0.1\" = \"Bandwidth 0.1\",\n  \"smoothed_y_h0.3\" = \"Bandwidth 0.3\",\n  \"smoothed_y_h0.5\" = \"Bandwidth 0.5\",\n  \"smoothed_y_h0.7\" = \"Bandwidth 0.7\",\n  \"smoothed_y_h1\"   = \"Bandwidth 1.0\"\n)\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_h0.1\" = \"blue\",\n  \"smoothed_y_h0.3\" = \"red\",\n  \"smoothed_y_h0.5\" = \"green\",\n  \"smoothed_y_h0.7\" = \"purple\",\n  \"smoothed_y_h1\"   = \"orange\"\n)\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line() +\n  labs(\n    title = \"Kernel Smoothing with Different Bandwidths\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/kernel-smoothing-1.png){width=672}\n:::\n:::\n\n:::\n\n## Smoothing Splines\n\nSmoothing splines are a flexible method for smoothing data by fitting a piecewise polynomial function to the data points. The smoothing spline minimizes the following objective function: $$\n\\sum_{i=1}^{n} \\{y_i - f(x_i)\\}^2 + \\lambda \\int (f''(x))^2 dx,\n$$ where $y_i$ are the observed data points, $f(x)$ is the smoothing spline, $\\lambda$ is the smoothing parameter that controls the trade-off between fidelity to the data and smoothness of the spline, and $f''(x)$ is the second derivative of the spline function.\n\n::: {.callout-example title=\"Example: Smoothing Splines\"}\nSuppose $\\mathbf{x}=(x_1,\\dots,x_n)$ and $y_i=\\sin(x_i)+N(0, 0.5^2)$ are the observed data points. We can apply smoothing splines with different smoothing parameters $\\lambda$ to smooth the data, where $\\lambda=0.01,0.1,1,10,100$. The following R code demonstrates how to implement smoothing splines with different smoothing parameters and visualize the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8670)\nn <- 100\nx <- seq(0, 10, length.out = n)\ny <- sin(x) + rnorm(n, sd = 0.5)\n\n# Smoothing spline using lambda (penalty on curvature)\nsmoothing_spline <- function(x, y, lambda) {\n  fit <- smooth.spline(x, y, lambda = lambda)  # <-- use lambda, not spar\n  predict(fit, x)$y\n}\n\n# Smoothing parameters (penalty sizes)\nlambda_values <- c(0.01, 0.1, 1, 10, 100)\n\nsmoothed_y_list <- lapply(lambda_values, function(lambda) {\n  smoothing_spline(x, y, lambda)\n})\n\n# Build data frame\ndf <- data.frame(x = x, y = y)\nfor (i in seq_along(lambda_values)) {\n  nm <- paste0(\"smoothed_y_lambda\", lambda_values[i])\n  df[[nm]] <- smoothed_y_list[[i]]\n}\n\n# Long format for ggplot\nlibrary(reshape2)\nlibrary(ggplot2)\n\ndf_melted <- melt(\n  df,\n  id.vars = \"x\",\n  variable.name = \"Type\",\n  value.name = \"Value\"\n)\n\n# Order legend & labels\nwanted_levels <- c(\"y\", paste0(\"smoothed_y_lambda\", lambda_values))\nlabels_named <- c(\n  y = \"Original Data\",\n  \"smoothed_y_lambda0.01\" = \"Lambda 0.01\",\n  \"smoothed_y_lambda0.1\"  = \"Lambda 0.1\",\n  \"smoothed_y_lambda1\"    = \"Lambda 1\",\n  \"smoothed_y_lambda10\"   = \"Lambda 10\",\n  \"smoothed_y_lambda100\"  = \"Lambda 100\"\n)\ncolors_named <- c(\n  y = \"gray50\",\n  \"smoothed_y_lambda0.01\" = \"blue\",\n  \"smoothed_y_lambda0.1\"  = \"red\",\n  \"smoothed_y_lambda1\"    = \"green\",\n  \"smoothed_y_lambda10\"   = \"purple\",\n  \"smoothed_y_lambda100\"  = \"orange\"\n)\n\ndf_melted$Type <- factor(df_melted$Type, levels = wanted_levels)\n\nggplot(df_melted, aes(x = x, y = Value, color = Type)) +\n  geom_line() +\n  labs(\n    title = \"Smoothing Splines with Different Penalties (lambda)\",\n    x = \"X\", y = \"Y\"\n  ) +\n  scale_color_manual(values = colors_named, labels = labels_named, drop = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](07-smoothing_files/figure-html/smoothing-splines-1.png){width=672}\n:::\n:::\n\n:::\n\n## Choice of the Method and the parameters\n\nThe choice of smoothing method and its parameters (e.g., window size for moving average, span for LOESS, bandwidth for kernel smoothing, and smoothing parameter for splines) depends on the specific characteristics of the data and the goals of the analysis. Here are some general guidelines:\n\n-   **Moving Average:** Simple and effective for evenly spaced data. Suitable for short-term trend analysis.\n-   **LOESS:** Flexible and can handle non-linear relationships. Good for exploratory data analysis.\n-   **Kernel Smoothing:** Provides a smooth estimate of the underlying function. The choice of bandwidth is crucial.\n-   **Smoothing Splines:** Offers a balance between fit and smoothness. The smoothing parameter controls this trade-off.\n\n## Conclusion\n\nSmoothing techniques are essential tools in statistics for reducing noise and revealing underlying patterns in data. In this chapter, we explored 3 common smoothing methods: moving average smoothing, kernel smoothing, and smoothing splines. Each method has its advantages and is suitable for different types of data and applications. By understanding and applying these techniques, we can enhance data quality and extract meaningful insights from noisy observations.\n\n------------------------------------------------------------------------\n\n## Reference\n\n-   Gu, C. (2013). [Smoothing Spline ANOVA Models](https://link.springer.com/book/10.1007/978-1-4757-3683-0). Springer, 2nd Edition.\n\n-   Ramsay, J.O., Hooker, G. and Graves, S. (2009). [Functional Data Analysis with R and MATLAB](https://link.springer.com/book/10.1007/978-0-387-98185-7). Springer.\n\n- Wikipedia, [Local Regression](https://en.wikipedia.org/wiki/Local_regression)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}