{
  "hash": "d7c43216a6f973e560f6c2018acbe2f3",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Structure and R Programming\n\nData types, operators, variables\n\nTwo basic types of objects: (1) data & (2) functions\n\n-   Data: can be a number, a vector, a matrix, a dataframe, a list or other datatypes\n\n-   Function: a function is a set of instructions that takes input, processes it, and returns output. Functions can be built-in or user-defined.\n\n## Data type\n\n-   Boolean/Logical: Yes or No, Head or Tail, True or False\n\n-   Integers: Whole numbers $\\mathbb{Z}$, e.g., 1, 2, 3, -1, -2, -3\n\n-   Characters: Text strings, e.g., \"Hello\", \"World.\"\n\n-   Floats: Noninteger fractional numbers, e.g., $\\pi$, $e$.\n\n-   Missing data: `NA` in R, which stands for \"Not Available.\" It is used to represent missing or undefined values in a dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nday <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nweather <- c(\"Raining\", \"Sunny\", NA, \"Windy\", \"Snowing\")\ndata.frame(rbind(day, weather))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             X1      X2        X3       X4      X5\nday      Monday Tuesday Wednesday Thursday  Friday\nweather Raining   Sunny      <NA>    Windy Snowing\n```\n\n\n:::\n:::\n\n\n-   Other more complex types\n\n### To change data type\n\nYou may change the data type using the following functions, but the chance is that some of the information will be missing. Do this with caution!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- pi\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.141593\n```\n\n\n:::\n\n```{.r .cell-code}\nx_int <- as.integer(x)\nprint(x_int)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\nSome of the conversion functions:\n\n-   `as.integer()`: Convert to integer.\n-   `as.numeric()`: Convert to numeric (float).\n-   `as.character()`: Convert to character.\n-   `as.logical()`: Convert to logical (boolean).\n-   `as.Date()`: Convert to date.\n-   `as.factor()`: Convert to factor (categorical variable).\n-   `as.list()`: Convert to list.\n-   `as.matrix()`: Convert to matrix.\n-   `as.data.frame()`: Convert to data frame.\n-   `as.vector()`: Convert to vector.\n-   `as.complex()`: Convert to complex number.\n\n## Operators\n\n-   Unary: With only **one** argument. E.g., `-x` (negation), `!x` (logical negation).\n\n-   Binary: With **two** arguments. E.g., `x + y` (addition), `x - y` (subtraction), `x * y` (multiplication), `x / y` (division).\n\n### Comparison Operator\n\nComparing two objects. E.g., `x == y` (equal), `x != y` (not equal), `x < y` (less than), `x > y` (greater than), `x <= y` (less than or equal to), `x >= y` (greater than or equal to).\n\n### Logical Operator\n\nLogical operators are used to combine or manipulate logical values (TRUE or FALSE). E.g., `x & y` (logical AND), `x | y` (logical OR), `!x` (logical NOT).\n\nWe shall note that the logical operators in R are vectorized, `x | y` and `x || y` are different. The former is vectorized, while the latter is not.\n\n``` r\nx <- c(TRUE, FALSE, FALSE)\ny <- c(TRUE, FALSE, FALSE)\nx | y  # [1]  TRUE FALSE FALSE\nx || y # This will return an error\n```\n\n## Indexing\n\nIndexing is a way to access or modify specific elements in a data structure. In **R**, indexing can be done using square brackets `[]` for vectors and matrices, or the `$` operator for data frames. Note that the index starts from **0** in **R**, which is different from some other programming languages like Python.\n\n## Naming\n\nIn **R**, you can assign names to objects using the `names()` function. This is useful for making your code more readable and for accessing specific elements in a data structure.\n\nA good practice is to use `_` (underscore) to separate words in variable names, e.g., `my_variable`. This makes the code more readable and easier to understand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign names to a vector\ntemp <- c(20, 30, 27, 31, 45)\nnames(temp) <- c(\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\")\nprint(temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Mon  Tues   Wed Thurs   Fri \n   20    30    27    31    45 \n```\n\n\n:::\n:::\n\n\n``` r\nrownames(temp) <- \"Day1\" # error\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_mat <- matrix(c(20, 30, 27, 31, 45), nrow = 1, ncol = 5)\ncolnames(temp_mat) <- c(\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\")\nrownames(temp_mat) <- \"Day1\" # error\nprint(temp_mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Mon Tues Wed Thurs Fri\nDay1  20   30  27    31  45\n```\n\n\n:::\n:::\n\n\n## Array and Matrix\n\nOne may define an array or a matrix in **R** using the `array()` or `matrix()` functions, respectively. An array is a multi-dimensional data structure, while a matrix is a two-dimensional array.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a 1-dimensional array\narray_1d <- array(1:10, dim = 10)\narray_1d\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a 2-dimensional array\narray_2d <- array(1:12, dim = c(4, 3))\narray_2d\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a 3-dimensional array\narray_3d <- array(1:24, dim = c(4, 3, 2))\narray_3d\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   13   17   21\n[2,]   14   18   22\n[3,]   15   19   23\n[4,]   16   20   24\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a matrix\nmy_matrix <- matrix(1:12, nrow = 4, ncol = 3)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n\n\n:::\n:::\n\n\nNote here, the matrix is a special case of an array, where the number of dimensions is exactly 2.\n\n``` r\nis.matrix(array_2d)   # TRUE\nis.matrix(my_matrix)  # TRUE\n\nis.array(array_2d)    # TRUE\nis.array(my_matrix)   # TRUE\n```\n\n## Key and Value Pair\n\nKey-Value Pair is a data structure that consists of a key and its corresponding value. In **R**, this can be implemented using named vectors, lists, or data frames. Usually, the most commonly used case is in the lists and data frames. The values can be extra by providing the corresonding key\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkey1 <- \"Tues\"\nvalue1 <- 32\nkey2 <- \"Wed\"\nvalue2 <- 28\n\nlist_temp <- list()\nlist_temp[[ key1 ]] <- value1\nlist_temp[[ key2 ]] <- value2\n\nprint(list_temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$Tues\n[1] 32\n\n$Wed\n[1] 28\n```\n\n\n:::\n\n```{.r .cell-code}\n## Now providing a key - Tues\n### First way\nlist_temp[[\"Tues\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n\n```{.r .cell-code}\n### Second way\nlist_temp$Tues\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n:::\n\n\n## Data Frame\n\nDataframe is a two-dimensional, tabular data structure in R that can hold different types of variables (numeric, character, factor, etc.) in each column. It is similar to a spreadsheet or SQL table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris <- datasets::iris\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n## Apply function\n\nThe `apply()` function is the basic model of the family of apply functions in R, which includes specific functions like `lapply()`, `sapply()`, `tapply()`, `mapply()`, `vapply()`, `rapply()`, `bapply()`, `eapply()`, and others. These functions are used to apply a function to elements of a data structure (like a vector, list, or data frame) in a (sometimes) more efficient and concise way than using loops.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- cbind(x1 = 3, x2 = c(4:1, 2:5))\ndimnames(x)[[1]] <- letters[1:8]\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x1 x2\na  3  4\nb  3  3\nc  3  2\nd  3  1\ne  3  2\nf  3  3\ng  3  4\nh  3  5\n```\n\n\n:::\n\n```{.r .cell-code}\napply(x, MARGIN = 2, mean) #apply the mean function to their \"columns\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx1 x2 \n 3  3 \n```\n\n\n:::\n\n```{.r .cell-code}\ncol.sums <- apply(x, MARGIN = 2, sum) #apply the sum function to their \"columns\"\nrow.sums <- apply(x, MARGIN = 1, sum) #apply the sum function to their \"rows\"\nrbind(cbind(x, Rtot = row.sums), Ctot = c(col.sums, sum(col.sums)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     x1 x2 Rtot\na     3  4    7\nb     3  3    6\nc     3  2    5\nd     3  1    4\ne     3  2    5\nf     3  3    6\ng     3  4    7\nh     3  5    8\nCtot 24 24   48\n```\n\n\n:::\n:::\n\n\nSome of the commonly used apply functions:\n\n-   **lapply**: Apply a Function over a List or Vector\n\n-   **sapply**: a user-friendly version and wrapper of lapply by default returning a vector, matrix\n\n-   **vapply**: similar to sapply, but has a pre-specified type of return value, so it can be safer (and sometimes faster) to use.\n\n## Tidyverse\n\nThe tidyverse is a collection of open source packages for the R programming language introduced by Hadley Wickham and his team that \"share an underlying design philosophy, grammar, and data structures\" of tidy data. Characteristic features of tidyverse packages include extensive use of non-standard evaluation and encouraging piping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load all tidyverse packages\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n## Or load specific packages in the tidy family\nlibrary(dplyr) # Data manipulation\nlibrary(ggplot2) # Data visualization\nlibrary(readr) # Data import\nlibrary(tibble) # Tidy data frames\nlibrary(tidyr) # Data tidying\n# ...\n```\n:::\n\n\n## Pipe\n\nPipe operator `|>` (native after R version 4.0) or `%>$` (from magrittr package) is a powerful tool in **R** that allows you to chain together multiple operations in a clear and concise way. It takes the output of one function and passes it as the first argument to the next function.\n\nFor example, we can write\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(777)\nx <- rnorm(5)\n\n## Without using pipe\nprint(round(mean(x), 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.37\n```\n\n\n:::\n\n```{.r .cell-code}\n## Using pipe\nx |> \n  mean() |> # applying the mean function\n  round(2) |> #round to 2nd decimal place\n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.37\n```\n\n\n:::\n:::\n\n\nWe can see that, without using the pipe, if we are applying multiple functions to the same object, we may have hard time to track. This can make the code less readable and harder to maintain. On the other hand, using pipe, we can clearly see the sequence of operations being applied to the data, making it easier to understand and modify.\n\n### Some rules\n\n`|>` should **always have a space before it** and should typically **be the last thing on a line**. This simplifies adding new steps, reorganizing existing ones, and modifying elements within each step.\n\nNote that all of the packages in the tidyverse family support the pipe operator (except `ggplot2`!), so you can use it with any of them.\n\n## Questions in class\n\n### Lecture 1, August 25, 2025\n\nQ1. If I know Python already, why learn R?\n\nReply: My general take are 1). R is more specialized for statistical analysis and data visualization, while Python is a more general-purpose programming language. 2). R has a rich ecosystem of packages and libraries specifically designed for statistical computing, making it a popular choice among statisticians and data scientists. 3). R's syntax and data structures are often more intuitive for statistical tasks, which can lead to faster development and easier collaboration with other statisticians. 4). Also, the tidyverse ecosystem including *ggplot* and others are a big plus when dealing with big dataframes. 5). They are not meant to replace each other, but work as a complement.\n\nQ2. Why my installation of R sometimes failed on a Windows machine?\n\nReply: There are many reasons. One of the most common reasons is that you may need to manually add the path to the environment variable.\n\n### Lecture 2, August 27, 2025\n\nQ1. What's the difference of using `apply` v.s. `looping` in R?\n\nReply: The apply functions are often faster and more efficient than looping, especially for large datasets, because they have done some vectorization under the hood. Also, it has much higher readibility and better conciseness. However, depends on the task, you may want to do the **benchmarking** to see the performance difference.\n\nQ2. How to use `pipe` with two or more variables?\n\nReply: There are several ways to do this.\n\n1.  Within the tidyverse family: One way is to use the `dplyr` package, which provides a set of functions that work well with the pipe operator. For example, you can use the `mutate()` function to create a new variable based on two existing variables. For example, you can do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(magrittr)  # for %$%\nlibrary(purrr)     # for pmap / exec if needed\n\nmy_df <- tibble(x = 1:5, y = 6:10)\nf  <- function(a, b) a + 2*b\n\nmy_df %>%\n  mutate(z = f(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n      x     y     z\n  <int> <int> <dbl>\n1     1     6    13\n2     2     7    16\n3     3     8    19\n4     4     9    22\n5     5    10    25\n```\n\n\n:::\n:::\n\n\n2.  Using base R, you may do something like the following through the `magrittr` package’s exposition pipe `%$%`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\n# method 1\nmy_df %$% f(x, y) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 16 19 22 25\n```\n\n\n:::\n\n```{.r .cell-code}\n# or use . as a placeholder\n# method 2\nmy_df %>% { f(.$x, .$y) }\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13 16 19 22 25\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\nSome of the materials are adapted from [CMU Stat36-350](https://www.stat.cmu.edu/~ryantibs/statcomp/).\n\nA comprehensive reference for all the *tidyverse* tools is [R for Data Science](https://r4ds.had.co.nz/).\n\nA comprehensive reference for *ggplot2* is [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}