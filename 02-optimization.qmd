# Numerical Approaches and Optimization

\newcommand{\bbeta}{\boldsymbol{\beta}}
\newcommand{\bX}{\boldsymbol{X}}
\newcommand{\bx}{\boldsymbol{x}}
\newcommand{\bZ}{\boldsymbol{Z}}
\newcommand{\bz}{\boldsymbol{z}}
\newcommand{\bv}{\boldsymbol{v}}
\newcommand{\bmu}{\boldsymbol{\mu}}
\newcommand{\R}{\mathbb R}

The optimization plays an important role in statistical computing, especially in the context of maximum likelihood estimation (MLE) and other statistical inference methods. This chapter will cover various optimization techniques used in statistical computing.


There is a general principle that will be repeated in this chapter that Kenneth Lange calls *optimization transfer* in his 1999 paper. The basic idea applies to the problem of maximizing a function $f$.

1. Direct optimize the function $f$.
    * It can be difficult
2. Optimize a surrogate function $g$ that is easier to optimize than $f$.
3. So here, instead of optimize $f$, we optimize $g$.

Note 1: steps 2&3 are repeated until convergence.

Note 2: maximizing $f$ is equivalent to minimizing $-f$.

Note 3: the surrogate function $g$ should be chosen such that it is easier to optimize than $f$.


For instance, for a linear regression 
\begin{equation}
  y = X\boldsymbol{\beta} + \varepsilon. \label{eq:linmod}
\end{equation}

From regression class, we know that the (ordinary) least-squares estimation (OLE) for $\bbeta$ is given by $\hat{\bbeta}=(X^\top X)^{-1} X^\top y$. It is convenient as the solution is in the **closed-form**! However, in the most case, the closed-form solutions will not be available.

For GLMs or non-linear regression, we need to do this **iterativelly**!

## Theory versus Computation

One confusing aspect of statistical computing is that often there is a disconnect between what is printed in a statistical computing textbook and what should be implemented on the computer. 

* In textbooks, simpler to **present solutions as convenient mathematical formulas whenever possible**, in order to communicate basic ideas and to provide some insight. 
    * However, directly translating these formulas into computer code is usually not advisable because there are many problematic aspects of computers that are simply not relevant when writing things down on paper.
    
Some potential issues includ:

1. Memory overflow: The computer has a limited amount of memory, and it is possible to run out of memory when working with large datasets or complex models.

2. Numerical Precision: Sometimes, due to the cut precision of floating-point arithmetic, calculations that are mathematically equivalent can yield different results on a computer. 
    * Example 1: round $1/3$ to two decimal places, we get $0.33$. Then, $3 \cdot (1/3)$ is exactly $1$, but $3 \cdot 0.33$ is $0.99$.
    * Example 2: $1 - 0.99999999$ is $0.00000001$ (=1E-8), but if we round $0.99999999$ to two decimal places, we get $1.00$, and then $1 - 1.00$ is $0$. If we round $0.00000001$ to two decimal places, we get $0.00$.
    * Example 3: $\pi$
3. (Lienar) Dependence: The detection of linear dependence in matrix computations is influenced by machine precision. Since computers operate with finite precision, situations often arise where true linear dependence exists, but the computer cannot distinguish it from independence.
    * Example: Consider the matrix 
    $$
    A = \begin{pmatrix}
    1 & 2 & 3 \\
    4 & 5 & 6 \\
    7 & 8 & 9 \\
    \end{pmatrix}
    $$
    The 3rd column is a linear combination of the first two columns (i.e., col3 = col1 + col2). However, due to machine precision limitations, the computer might not recognize this exact linear dependence, leading to numerical instability in computations involving this matrix. With a small distortion, we have
      $$
    B = \begin{pmatrix}
    1 & 2 & 3 \\
    4 & 5 & 6 \\
    7 & 8 & 9 + 10^{-5} \\
    \end{pmatrix}
    $$
```{r}
A <- matrix(
  c(1, 2, 3,
    4, 5, 6,
    7, 8, 9),
  nrow = 3, ncol = 3, byrow = TRUE)
B <- A
B[3, 3] <- B[3, 3] + 1E-5

qr(A)$rank
qr(B)$rank
```

## Matrix Inversion

In many statistical analyses, such as linear regression and specify the distribution (such as normal distribution), matrix inversion plays a central role.

### Example 1: Normal distribution

We know that, a normal density with the parameters mean $\mu$ and standard deviation $\sigma$ is 
$$
f\left(x \mid \mu, \sigma^2\right)=\frac{1}{\sqrt{2 \pi} \sigma} \exp\left\{-\frac{1}{2 \sigma^2}(x-\mu)^2\right\}
$$
or we may work on the multivariate normal distribution case which is a bit more involved.

::: {.callout-definition title="Multivariate normal distribution"}
$\boldsymbol{X} = (X1,\dots, X_d)$ is said to be a multivariate normal distribution if and only if it is a linear comibnation of independent and identically distributed standard normals: 
$$
\boldsymbol{X} = \boldsymbol{CZ} + \mu,\quad \boldsymbol{Z}=(Z_1,\dots,Z_d),\quad Z_i \stackrel{iid}{\sim} N(0,1).
$$
:::

The property of the multivariate normal are:

* mean vector: $E(\boldsymbol{X}) = \mu$
* variance: $Var(\boldsymbol{X}) = \boldsymbol{CZC}^\top = \boldsymbol{C} var(\bZ)\boldsymbol{C}^\top:=  \boldsymbol{\Sigma}$

Notation: $\boldsymbol{X} \sim N(\mu, \boldsymbol{\Sigma})$.

PDF:
$$
f(\boldsymbol{x} \mid \mu, \Sigma)=(2 \pi)^{-d / 2} \cdot \exp \left\{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{\prime} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})-\frac{1}{2} \log |\boldsymbol{\Sigma}|\right\}.
$$
Some of the potential ways to do this is to take logarithm of the PDF (Think about why).



### Example 2: Linear regression

Recall the linear regression model . The OLE for $\bbeta$ is given by $\hat{\bbeta}=(X^\top X)^{-1} X^\top y$.

We can solve this using the R command

``` r
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
```
where `solve()` is the R function for matrix inversion. However, it is not a desired way (think about why).

A better way is to go back to the formula, and look at
$$
X^\top X\bbeta = X^\top y,
$$
and solve this using the R command

``` r
solve( crossprod(X), crossprod(X, y) ) 
# this is the same as 
# solve(t(X) %*% X, t(X) %*% y)
```

Here, we avoid explicitly calculating the inverse of $X^\top X$. Instead, we use gaussian elimination to solve the system of equations, which is generally more numerically stable and efficient.

#### Speed comparison

``` r
set.seed(2025-09-03)
X <- matrix(rnorm(5000 * 100), 5000, 100)
y <- rnorm(5000)
library(microbenchmark)
microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y)
```

```         
Unit: milliseconds
                             expr      min       lq
 solve(t(X) %*% X) %*% t(X) %*% y 28.83505 30.16593
     mean   median       uq      max neval
 31.96782 30.79489 32.63315 111.0151   100
Warning message:
In microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y) :
  less accurate nanosecond times to avoid potential integer overflows
```

``` r
microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y,
               solve(crossprod(X), crossprod(X, y)))
```

```         
Unit: milliseconds
                                 expr      min       lq
     solve(t(X) %*% X) %*% t(X) %*% y 28.90135 30.11608
 solve(crossprod(X), crossprod(X, y)) 25.05859 25.27480
     mean   median       uq      max neval
 31.78686 31.38513 32.66482 53.03354   100
 26.15771 25.81678 26.89188 29.12045   100
```

### Take home message:

The take home here is that the issues arise from the finite precision of computer arithmetic and the limited memory available on computers. When implementing statistical methods on a computer, it is crucial to consider these limitations and choose algorithms and implementations that are robust to numerical issues.

### Multi-collinearity

The above approach may break down when there is any multi-colinearity in the $\bX$ matrix. For example, we can tack on a column to $\bX$ that is very similar (but not identical) to the first column of $\bX$.

```{r}
set.seed(7777)
N <- 3000
K <- 100
y <- rnorm(N)
X <- matrix(rnorm(N * K), N, K)
W <- cbind(X, X[, 1] + rnorm(N, sd = 1E-15))
```

``` r
solve(crossprod(W), crossprod(W, y))

Error in `solve.default()`:
! system is computationally singular: reciprocal condition number = 1.36748e-32
```
The algorithm does not work because the cross product matrix $W^\top W$ is **singular**. In practice, matrices like these can come up a lot in data analysis and it would be useful to have a way to deal with it automatically.

R takes a different approach to solving for the unknown coefficients in a linear model. R uses the QR decomposition, which is not as fast, but has the added benefit of being able to automatically detect and handle colinear columns in the matrix.

Here, we use the fact that X
can be decomposed as $\bX=QR$, where $Q$ is an orthonormal matrix and $R$ is an upper triangular matrix. Given that, we can rewrite $X^\top X \bbeta = X^\top y$ as
\begin{align*}
R^\top Q^\top Q R \bbeta &= R^\top Q^\top y\\
R^\top I R \bbeta &= R^\top Q^\top y\\
R^\top R \bbeta &= R^\top Q^\top y,
\end{align*}
this leads to $R\bbeta = Q^\top y$. Now we can perform the Gaussian elimination to do it. Because $R$ is an upper triangular matrix, the computational speed is much faster.  Here, we **avoid to compute the cross product $X^\top X$**, which is numerical unstable if it is not *standardized* properly
 
We can see in R code that even with our singular matrix $W$ above, the QR decomposition continues without error.

```{r}
Qw <- qr(W)
str(Qw)
```

Note that the output of `qr()` computes the rank of $W$ to be 100, not 101 as the last column is collinear to the 1st column. From there, we can get $\hat{\bbeta}$ if we want using `qr.coef()`,

```{r}
betahat <- qr.coef(Qw, y)
head(betahat, 3)
tail(betahat, 3)
```

Q: Why there is an `NA`?

### Trade-off

There isnâ€™t always elegance and flourish. When we take the robust approach, we accept that it comes at a cost.


```{r}
library(ggplot2)
library(microbenchmark)
m <- microbenchmark(solve(t(X) %*% X) %*% t(X) %*% y,
                    solve(crossprod(X), crossprod(X, y)),
                    qr.coef(qr(X), y))
autoplot(m)
```


Compared with the approaches discussed above, this method performs similarly to the naive approach but is much more stable and reliable.

In practice, we rarely call functions such as `qr()` or `qr.coef()` directly, since higher-level functions like lm() handle these computations automatically. However, in certain specialized and performance-critical settings, it can be advantageous to use alternative matrix decompositions to compute regression coefficients, especially when the computation must be repeated many times in a loop (i.e., *Vectorization*)

### Multivariate Normal revisit

Computing the multivariate normal (MVN) density is a common task, for example, when fitting spatial models or Gaussian process models. Because maximum likelihood estimation(MLE) and likelihood ratio tests (LRT) often require evaluating the likelihood many times, efficiency is crucial.

After taking the log of the MVN density, we have 

$$
\ell(\bx \mid \bmu,\Sigma) := \log \left\{ f(\bx \mid \bmu,\Sigma) \right\} 
= -\frac{d}{2}\log(2\pi) - \frac{1}{2}\log|\Sigma| - \frac{1}{2}(\bx-\bmu)^\top \Sigma^{-1}(\bx-\bmu).
$$
On the right hand side, the first term is a constant, the second term is linear, and the last term is quadratic, which requires much more computational power. 


#### A Naive Implementation

We first center the data $\bz:=\bx - \mu$. Then we have $\bz^\top \Sigma^{-1} \bz$. This simiplified the question for a bit.

Here, much like the linear regression example above, the key bottleneck is the inversion of the $p$-dimensional covariance matrix $\Sigma$. If we take $\bz$ to be a $p\times 1$ column vector, then a literal translation of the mathematics into R code might look something like this,

``` r
t(z) %*% solve(Sigma) %*% z
```

To illustrate, letâ€™s simulate some data and compute the quadratic form the naive way:

```{r, message = F, warning = F}
set.seed(2025-09-03)

# Generate data
z <- matrix(rnorm(200 * 100), 200, 100)
S <- cov(z)

# Naive quadratic form
quad.naive <- function(z, S) {
  Sinv <- solve(S)
  rowSums((z %*% Sinv) * z)
}

library(dplyr)
quad.naive(z, S) %>% summary()
```

#### A Better Way: Cholesky Decomposition

Because the covariance matrix \Sigma is symmetric and positive definite, we can exploit its **Cholesky decomposition**. That is, we write $\Sigma = R^\top R$, where $R$ is a upper triangular matrix. Then,
$$
\bz^\top \Sigma^{-1} \bz = \bz^\top (R^\top R)^{-1} \bz = \bz^\top R^{-1}R^{-\top} \bz = (R^{-\top}\bz)^\top (R^{-\top} \bz) := \bv^\top \bv.
$$
Note that $\bv \in \R^p$ is the solution to the linear system $R^\top \bv = \bz$. Because $R$ is upper triangular, we can solve this system efficiently using back substitution. Also, we can solve this without doing the inversion.

Once we have $\bv$ we can compute its quadratic form $\bv^\top \bv$ by the `crossprod()` function.

```{r}
quad.chol <- function(z, S) {
  R <- chol(S)
  v <- backsolve(R, t(z), transpose = TRUE)
  colSums(v * v)
}

quad.chol(z, S) %>% summary()
```

#### By product

Another benefit of the Cholesky decomposition is that it gives us a simple way to compute the log-determinant of $\Sigma$. The log-determinant of $\Sigma$ is simply two times the sum of the log of the diagonal elements of R. (Why?)

#### Performance comparison

```{r}
library(microbenchmark)
library(ggplot2)
m2 <- microbenchmark(
  naive = quad.naive(z, S),
  chol  = quad.chol(z, S)
)
autoplot(m2)
```

Q: Why one is faster than the other?


#### Take home message 2

The naive algorithm simply inverts the covariance matrix. The Cholesky-based approach, on the other hand, exploits the fact that covariance matrices are symmetric and positive definite. This results in an implementation that is both faster and numerically more stableâ€”exactly the kind of optimization that makes a difference in real-world statistical computing. 


Thus, a knowledge of statistics and numerical analysis can often lead to better algorithms, often invaluable!

----


## We will touch the concept below in next class

## Type of Optimization Algorithms

There are in general two types of the optimization algorithms: (1). **deterministic** and (2). **metaheuristic**. Deterministic and metaheuristic algorithms represent two distinct paradigms in optimization. Deterministic methods, such as gradient descent, produce the same solution for a given input and follow a predictable path toward an optimum. In contrast, metaheuristic approachesâ€”like genetic algorithmsâ€”incorporate randomness and do not guarantee the best possible solution. However, they are often more effective at avoiding local optima and exploring complex search spaces.

## Heuristic Algorithms

Many of the heuristic algorithms are inspired by the nature, such as the genetic algorithm (GA) and particle swarm optimization (PSO). These algorithms are often used for complex optimization problems where traditional methods may struggle to find a solution. Some of the popular heuristic algorithms include:

-   Genetic Algorithm (GA)
-   Particle Swarm Optimization (PSO)
-   Simulated Annealing (SA)
-   Ant Colony Optimization (ACO)

## Deterministic Algorithms

Numerical approximation, what you learned in the mathematical optimization course. Some of the algorithms include:

-   Gradient Descent
-   Newton's Method
-   Conjugate Gradient Method
-   Quasi-Newton Methods (e.g., BFGS)
-   Interior Point Methods

They often reply on the KKT conditions.

### In R

`optim()` function, `nlm()` function or `mle()` function.

### EM Algorithm

The EM (Expectationâ€“Maximization) algorithm is an optimization method that is often applied to find maximum likelihood estimates when data is incomplete or has missing values. It iteratively refines estimates of parameters by alternating between (1) expectation step (E-step) and (2) maximization step (M-step).

::: {.callout-note title="Tip with Title"}
For example, consider the function $f(x) = x^2$.
:::

::: callout-example
Example

$$
f(x) = x^2
$$
:::

::: callout-theorem
Example Theorem
:::

------------------------------------------------------------------------

Examples are borrowed from the following sources:

-   Peng, R.D. [Advanced Statistical Computing](https://bookdown.org/rdpeng/advstatcomp/).
